#include "uart.h"

#define LO8(var) ((unsigned char)((var)&0xFF))
#define HI8(var) ((unsigned char)((var>>8)&0xFF))

void InitUART (void)
{
  UBRR0L=LO8(Baudrate_Register); // Установка скорости последовательного порта
  UBRR0H=HI8(Baudrate_Register);
  // (0xD0 1101 0000 by Default)
  // UCSR0B = RXCIE0, TXCIE0, UDRIE0, RXEN0, TXEN0, UCSZ0, RXB80, TXB80
  // RXEN0=1  По умолчанию приемник включен
  // TXEN0=0  По умолчанию передатчик выключен
  // RXCIE0=1 Receive Interrupt Enable
  // TXCIE0=1 Transmit Interrupt Enable

  UCSR0B = (1<<RXEN0)|(0<<TXEN0)|(1<<RXCIE0)|(1<<TXCIE0);

  // UCSR0C = URSEL0, UMSEL0, UPM01, UPM00, USBS0, UCSZ01, UCSZ00, UCPOL0
  // URSEL0=1 Register Select UCSRC or UBRRH
  // UMSEL0 - Synchronous/Asynchronous Mode of UART (0=Async)
  // UPM01..00 - Parity Mode (0=Disabled)
  // USBS0 - Stop Bits (0=One Stop Bit, 1=Two Stop Bits)
  // UCSZ01..00=11 - Character Size (11=8 Bit)
  // UCPOL0 - Clock Polarity (установить только при синхронном режиме)
  
  UCSR0C = (1<<URSEL0)|(1<<UCSZ01)|(1<<UCSZ00);
  
}

// ===========================================================================
//  UART RXC INTERRUPT
// Прерывание UART по окончании приема
// В прерывании по приему байта из UART сразу проверяется сетевой
// адрес устройства на шине Modbus, а также валидные номера функций
// для данного прибора, а затем уже идет прием информации в буфер
// приема UART_Buf. После того как в буфер будет записан последний байт,
// пройдет ~ 3 мс таймаута (посчитает таймер2) и приемник отключится,
// чтобы не принимать возможную помеху. При этом, по окончании успешного приема,
// в функции прерывания таймера2 установится флаг EINF о том, что информация получена.
// Для получения следующего пакета данных, нужно включить приемник, 
// сбросить флаг EINF.

#pragma vector=USART0_RXC_vect
__interrupt void USART_RX(void)
{
  
  unsigned char c;
  c=UDR0; // Сразу берем результат из регистра приемника

// На входе обработчик сетевого адреса и валидных номеров функций Modbus
// Устанавливает внутренний флаг ошибки ErrorUART для последующей проверки
/*
  if ( (HowMany_RX==0) && (c!=Net_Addr) )  // Если это первый принятый байт, то проверяем сетевой адрес.
    {
      // Если первый принятый байт не равен сетевому адресу, то
      TimeOut_RX=0; // Установка счетчика таймаута в ноль
      HowMany_RX=0;  // Сброс счетчика принятых байт и вываливаемся из прерывания.
      return;
    }
*/

  // если всё ОК, то записываем в буфер принятый байт и увеличиваем указатель,
  // а также переустанавливаем счетчик таймаута по приему
  LED_RX=0; // Включаем LED приемника
  UART_Buf[HowMany_RX]=c;  // Записываем принятый байт в буфер
  HowMany_RX++;            // Увеличиваем счетчик байтов
  TimeOut_RX=TIMEOUT; // Переустановка счетчика таймаута по приему (~3 ms)
  // Счетчик таймаута сбрасывается каждый раз после приема очередного байта
  // в буфер UART_Buf. Время приема одного байта на скорости 9600 бод
  // ~ 1 мс, таким образом, устанавливая на прерывания таймера2 счетчик таймаута
  // равным примерно 3 мс (прерывания таймера2 = ~ 1 мс), делается автоматическое
  // завершение приема установкой соотв. флага EINF в 0xFF (не равное нулю).
  // После этого отключается прием, чтобы вновь принятая (внезапно) информация
  // (а это может быть помеха по линии приема) не начала помещаться в буфер
  // приема и происходило квитирование функций приема. После анализа флага
  // EINF о том, что какая-то информация в буфер получена, нужно вызвать
  // процедуру анализа и обработки протокола Modbus, затем включить приемник
  // для приема следующего валидного пакета.
}

//===========================================================================
//  UART TXC INTERRUPT
// Прерывание UART по окончании передачи
// После передачи всего пакета, отключается передатчик и
// включается приемник, кол-во принятых байт сбрасывается в ноль,
// гасится светодиод.
// На время передачи приемник отключен.

#pragma vector=USART0_TXC_vect
__interrupt void USART_TX(void)
{
  if (HowMany_TX >= Pointer_TX)
    {
      // Процесс передачи
      unsigned char c=UART_Buf[Pointer_TX]; // Берем байт из буфера по текущему указателю
      Pointer_TX++;           // Увеличиваем указатель
      UDR0=c; // Кладем в регистр передатчика - передаем
    }
  else
    {
      // По окончании передачи
      UCSR0B&=~(1<<TXEN0); // Выключение передатчика TXEN0=0
      UCSR0B|=(1<<RXEN0); // Включение приемника
      HowMany_RX=0;
      HowMany_TX=0;
      LED_TX=1;  // Гасим LED_TX
    }
}

//==========================================================================
// Процедура начала передачи по UART
// howmanyTX - сколько байт нужно передать
// Данные для передачи уже должны быть в буфере UART_Buf
// После этой процедуры запускаются прерывания по TXC
// и оставшиеся данные в буфере передаются по прерываниям.
// Включается светодиод передачи.
// На время передачи приемник отключен.

void Transmit (unsigned char howmanytx)
{

//  if (howmanytx!=0) // Если количество передаваемых байт равно нулю, то сразу выход
//    {
      LED_TX=0; // Включаем LED - начало передачи
      HowMany_TX=(howmanytx-1); // Указывает, сколько байт передавать в прерывании
      Pointer_TX=1; // Указатель в буфере для прерывания = 0+1
      UDR0=UART_Buf[0]; // Передаем первый байт из буфера
      // Переключили направление (удобно для RS485) - откл. прием, вкл. передачу
      UCSR0B&=~(1<<RXEN0);
      UCSR0B|=(1<<TXEN0); // Запуск передатчика, далее обрабатывается прерывание TXC
//    }
}



