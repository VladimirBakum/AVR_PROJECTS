// Длина всей посылки 11-битного кода занимает ~ 0,7 мс;
// Период одного клока ~ 66 мкс (15 кГц) (0,066*11=0,726 мс);
// Верхний и нижний полупериоды тактового сигнала примерно равны между собой - 33 мкс;
// У двух разных клавиатур эти временные хар-ки идентичны.

#include "keyboard.h"
#include "scancodes.h"

//===============================================================

void init_keyboard(void)
{
  input_pointer =  kb_buffer; // Инициализация буфера
  output_pointer = kb_buffer;
  buffcnt = 0;
  is_up=0;
  shift=0;
  mode=0;

  bitcount = 11;  // Стартовый=0, 8 бит данных, проверочный, стоповый=1
  TimeOut_KBD=0;

  MCUCR = (0<<ISC01)|(1<<ISC00);  // Установка прерывания INT0 по изменению лог. состояния    
  EIMSK|= (1<<INT0);            // Разрешение прерывания INT0
}

//===========================================================
// Запись принятого кода клавиши в буфер клавиатуры

void put_kbbuff(unsigned char c)
{
    if (buffcnt<KBD_BUFF_SIZE)    // If buffer not full
    {
        *input_pointer = c;                // Сохраняем код клавиши в буфере
        input_pointer++;                   // Increment pointer

        buffcnt++;    // Счетчик принятых кодов клавиш увеличиваем
    
        if (input_pointer >= kb_buffer + KBD_BUFF_SIZE)        // Pointer wrapping
          {
            input_pointer = kb_buffer;
          }
    }
}

//===========================================================
// Процедура всё время получает принятый байт с клавиатуры


void decode(unsigned char sc)
{
    unsigned char i;

    // Если is_up=0
    if (!is_up)       // Последний принятый идентификатор был идентификатором отпускания кнопки
     {
        switch (sc)
        {
          case 0xF0 :        // Идентификатор отпускания кнопки
            {
              is_up = 1;
              break;
            }
          case 0x12 :        // Левый SHIFT
            {
              shift = 1;
              break;
            }
          case 0x59 :        // Правый SHIFT
            {
              shift = 1;
              break;
            }
          case 0x05 :        // F1
            {
              if(mode == 0)
                {
                  mode = 1;    // Вход в режим скан-кода
                }
              if(mode == 2)
                {
                  mode = 3;    // выход из режима скан-кода
                }
              break;
            }

          default:
            {
              if(mode == 0 || mode == 3)        // Если режим ASCII
               {
                  if(!shift)  // ----------- Если SHIFT не нажата
                    {                            // тогда надо просмотреть таблицу
                      for(i = 0; unshifted[i][0]!=sc && unshifted[i][0]; i++)
                        {
                          if (unshifted[i][0] == sc) 
                            {
                              put_kbbuff(unshifted[i][1]);
                            }
                        }
                     }
                  else 
                    {          // -------------  если SHIFT нажата
                      for(i = 0; shifted[i][0]!=sc && shifted[i][0]; i++)
                        {
                          if (shifted[i][0] == sc) 
                            {
                              put_kbbuff(shifted[i][1]);
                            }
                        }
                    }
               }
              else
               {                            // режим скан-кода
//                  print_hexbyte(sc);            // Вывод скан-кода
                  put_kbbuff(' ');
                  put_kbbuff(' ');
               }
              break;
            }
        }
      } 
    else 
     {
        is_up = 0;                            // Два кода 0xF0 в строке невозможно
        switch (sc)
        {
          case 0x12 :                        // Левый SHIFT
            {
              shift = 0;
              break;
            }
          case 0x59 :                        // Правый SHIFT
            {
              shift = 0;
              break;
            }
          case 0x05 :                        // F1
            {
              if(mode == 1)
                {
                  mode = 2;
                }
              if(mode == 3)
                {
                  mode = 0;
                }
              break;
            }
          case 0x06 :                        // F2
            {
//              clr();
              break;
            }
         } 
      }   
} 

//=============================================================================
// Прерывание разбито на две ветки, первая - обработка спадающего фронта CLK
// Вторая - обработка нарастающего фронта CLK.

#pragma vector=INT0_vect
__interrupt void INT0_interrupt(void)
{

    if (TimeOut_KBD==0 && bitcount==11) // Проверка на первое вхождение
      {
        kbd_data_byte=0; // Исходные данные для заполнения байта
        kbd_data_mask=0x01;
        TimeOut_KBD=TIMEOUT_KEYBOARD; // Переустановкой таймаута не ноль мы говорим о том что поехало!
      }
  
    if (KBD_PIN & (1<<KBD_CLK))      // Выбор ветки в зависимости от того какой уровень CLK
      {                            //----------------------- Лог. уровень CLK = 1 - выход
        LED_PORT|=(1<<LED_KBD);  // Гасим LED

        bitcount--; // По выходу уменьшаем счетчик битов
        TimeOut_KBD=TIMEOUT_KEYBOARD; // После приема очередного бита не даем наступить таймауту
        
        if (bitcount == 0)  // Все биты получены? Отправляем на декодирование и в буфер
          {
            put_kbbuff(kbd_data_byte); // Отправляем принятый байт в процедуру декодирования
// Инициализация счетчика бит для приема следующего байта осуществляется в прерывании по таймауту
          }
        
       } 
    else 
     {                                // --------------------- Лог. Уровень CLK = 0 - вход опроса бита
        LED_PORT&=~(1<<LED_KBD); // Включаем LED - начало
         if(bitcount > 2 && bitcount < 11)    // Биты с 3 по 10 – биты данных. Parity bit,
            {                                    // старт- и стоп- биты игнорируются
              if(KBD_PIN & (1<<KBD_DATA))  // Берем значение бита DATA
                {
                  kbd_data_byte |= kbd_data_mask;  // Если была единица то делаем OR результата и маски
                }
              kbd_data_mask<<=1; // Двигаем маску влево
            }
      }
}

//===========================================================================

unsigned char getchar_kbd(void)
{
    unsigned char byte;
    while(buffcnt == 0);                   // Ожидание данных

      byte = *output_pointer;                                // Get byte
      output_pointer++;                                    // Increment pointer

      if (output_pointer >= kb_buffer + KBD_BUFF_SIZE)            // Просмотр указателя
        {
          output_pointer = kb_buffer;
        }
    
      buffcnt--;                                    // Decrement buffer count

    return byte;
}

//==============================================================================
// Для начала нам нужно определить, когда клава освободила шину ps2
// чтобы можно было бесконфликтно к ней достучаться.
// Т.к. для передачи команды клава выставляет клоки сама (выступает мастером на шине),
// то есть два способа - либо отключить прерывания и работать только в этой процедуре,
// либо подпрограмму прерывания по INT перводить в другой режим - режим передачи команды.
// Мы выбираем... надо подумать... Подуманье пришло к выводу, что работа в прерываниях
// слишком усложнит код, тем более, что клаву нужно будет определять по времени доступа,
// на случай, если вдруг она зависла или была отключена.
// Значит во время передачи байта клаве прерывания INT временно отключаем.
// Фактически процедура должна возвращать флаг о том, была ли успешно передана команда.
// Возврат FF - OK, если 0 - таймаут или ошибка.
// На входе - байт для передачи.

unsigned char keyboard_command(unsigned char comm)
{
  KBD_DDR|=(1<<KBD_CLK); // Линия CLK на вывод, чтобы управлять шиной

  KBD_PORT&=~(1<<KBD_CLK); // CLK=0
  delay_us(33);

  //--------------------------- Передача стартового бита ----------------------
  KBD_DDR|=(1<<KBD_DATA); // Линия данных работает на вывод
  KBD_PORT&=~(1<<KBD_DATA); // Set DATA Low - стартовый бит=0
  delay_us(33);
  KBD_PORT|=(1<<KBD_CLK); // CLK=1
  KBD_DDR&=~(1<<KBD_CLK); // Линия CLK На ввод - теперь клава будет клокать а мы выставлять данные
  // После того как CLK взведен и линия CLK отпущена - Теперь клава должна клокать, 
  // а мы успевать подставлять требуемые биты. При этом стартовый бит 0 мы уже выставили.

  TimeOut_KBD=TIMEOUT_KEYBOARD; // Таймаут для подсчета времени ожидания реакции от клавы
  while (KBD_PIN & (1<<KBD_CLK)) // Цикл выполняется до тех пор пока CLK=1
    {
      if (TimeOut_KBD==0)
        {
          return (0); // Если таймаут наступил то выходим с ошибкой
        }
    }
  // Дождались пока CLK стал 0 - клава взяла бит с шины данных

  // Ждем возвращения линии CLK в исходное состояние 1
  TimeOut_KBD=TIMEOUT_KEYBOARD;
  // Ждем, пока CLK перейдет из 0 в 1
  while (!(KBD_PIN & (1<<KBD_CLK))) // Цикл выполняется до тех пор пока CLK=0
    {
      if (TimeOut_KBD==0)
        {
          return (0); // Если таймаут наступил то выходим с ошибкой
        }
    }

  //------------- Далее следует цикл передачи байта. Первым идет младший бит. ---------------
  unsigned char parity_register=0; // Регистр для подсчета паритета
  unsigned char i; // Счетчик бит
  for (i=0;i<8;i++)
    {
      // Сначала выставляем бит данных
      if (comm&0x01)
        {
          KBD_PORT|=(1<<KBD_DATA); // Если была 1
          parity_register++; // Увеличивем счетчик единичных бит
        }
      else
        {
          KBD_PORT&=~(1<<KBD_DATA);
        }

      // Теперь ждем, пока клава не проглотит выставленный бит данных - CLK перейдет из 1 в 0
      TimeOut_KBD=TIMEOUT_KEYBOARD; // Таймаут 5 мс для подсчета времени ожидания реакции от клавы
      while (KBD_PIN & (1<<KBD_CLK)) // Цикл выполняется до тех пор пока CLK=1
        {
          if (TimeOut_KBD==0)
            {
              return (0); // Если таймаут наступил то выходим с ошибкой
            }
        }
      // Дождались пока CLK стал 0
      // Ждем возвращения линии CLK в исходное состояние 1

      TimeOut_KBD=TIMEOUT_KEYBOARD;
      // Ждем, пока CLK перейдет из 0 в 1
      while (!(KBD_PIN & (1<<KBD_CLK))) // Цикл выполняется до тех пор пока CLK=0
        {
          if (TimeOut_KBD==0)
            {
              return (0); // Если таймаут наступил то выходим с ошибкой
            }
        }
      
      comm>>=1; // Сдвигаем байт данных вправо
       
    }

  // Once the Parity bit has been set and the falling edge of the KBD clock detected, 
  // we must release the KBD data line, and wait for another falling edge of the KBD clock 
  // to see if the Keyboard has acknowledged the byte.
  // После того как бит паритеты был выставлени и спадающий фронт CLK наступил,
  // мы должны освободить линию данных и дождаться следующего спадающего фронта CLK,
  // чтобы увидеть что клава подтвердила прием байта.

  //----------------------------- Передача бита паритета ---------------------
  // Выставляем на линию данных бит паритета
  if (parity_register&0x01)
    {
      KBD_PORT&=~(1<<KBD_DATA); // Если была единица то шина данных=0
    }
  else
    {
      KBD_PORT|=(1<<KBD_DATA); // Шина данных=1
    }

  // Теперь ждем, пока клава не проглотит выставленный бит данных - CLK перейдет из 1 в 0
  TimeOut_KBD=TIMEOUT_KEYBOARD; // Таймаут для подсчета времени ожидания реакции от клавы
  while (KBD_PIN & (1<<KBD_CLK)) // Цикл выполняется до тех пор пока CLK=1
    {
      if (TimeOut_KBD==0)
        {
          return (0); // Если таймаут наступил то выходим с ошибкой
        }
    }
  // Дождались пока CLK стал 0 - бит паритета заглотила клава
  
  // Ждем возвращения линии CLK в исходное состояние 1
  TimeOut_KBD=TIMEOUT_KEYBOARD;
  // Ждем, пока CLK перейдет из 0 в 1
  while (!(KBD_PIN & (1<<KBD_CLK))) // Цикл выполняется до тех пор пока CLK=0
    {
      if (TimeOut_KBD==0)
        {
          return (0); // Если таймаут наступил то выходим с ошибкой
        }
    }

  //----------------------------- Передача стопового бита -----------------------
  // Дождались пока CLK стал 1 - освобождаем линию данных, передаем стоповый бит.
  
  KBD_PORT|=(1<<KBD_DATA); // Шина данных=1
  KBD_DDR&=~(1<<KBD_DATA); // Линия данных на ввод - освобождаем шину
  
  TimeOut_KBD=TIMEOUT_KEYBOARD;
  while (KBD_PIN & (1<<KBD_CLK)) // Цикл выполняется до тех пор пока CLK=1
    {
      if (TimeOut_KBD==0)
        {
          return (0); // Если таймаут наступил то выходим с ошибкой
        }
    }
  // Дождались пока CLK стал 0
  
  // Ждем возвращения линии CLK в исходное состояние 1
  TimeOut_KBD=TIMEOUT_KEYBOARD;
  // Ждем, пока CLK перейдет из 0 в 1
  while (!(KBD_PIN & (1<<KBD_CLK))) // Цикл выполняется до тех пор пока CLK=0
    {
      if (TimeOut_KBD==0)
        {
          return (0); // Если таймаут наступил то выходим с ошибкой
        }
    }
  // Сразу после того как CLK=0 мы читаем линию данных - подтверждение клавы.
  // Если клава ответила нулём, то всё ОК.

  if (KBD_PIN & (1<<KBD_DATA))
    {
      return (0); // Если клава не ответила нулём то считаем что ошибка - вываливаемся
    }

  // ----------------- В самом конце - ждем возвращения линии CLK в исходное состояние 1 -----------
  TimeOut_KBD=TIMEOUT_KEYBOARD;
  // Ждем, пока CLK перейдет из 0 в 1
  while (!(KBD_PIN & (1<<KBD_CLK))) // Цикл выполняется до тех пор пока CLK=0
    {
      if (TimeOut_KBD==0)
        {
          return (0); // Если таймаут наступил то выходим с ошибкой
        }
    }

  TimeOut_KBD=TIMEOUT_KEYBOARD;
  // Ждем, пока линия DATA освободится
  while (!(KBD_PIN & (1<<KBD_DATA))) // Цикл выполняется до тех пор пока DATA=0
    {
      if (TimeOut_KBD==0)
        {
          return (0); // Если таймаут наступил то выходим с ошибкой
        }
    }
    
  return (0xFF);
}

//===========================================================================
// Из-за того, что отключаем прерывания и из-за внезапного выхода по таймауту
// пришлось делать вложенность подпрограмм

unsigned char kbd_command(unsigned char cmd)
{
  unsigned char responce;

  // По идее этот цикл ожидания не должен зависнуть т.к. прерывания таймера контролируют
  // переменные TimeOut_KBD и bitcount
  while (!(TimeOut_KBD==0 && bitcount==11)); // Условие того что шина свободна - ждем пока освободится

  EIMSK&= ~(1<<INT0);  // Прежде чем дергать ногой CLK отключаем прерывания INT0, иначе улетим туда :)
  
  responce=keyboard_command(cmd);

  // Вне зависимости от того, всё нормально или нет - возвращаем параметры прерывания для приема кода с клавы
  TimeOut_KBD=TIMEOUT_KEYBOARD;
  EIMSK|= (1<<INT0); // Разрешение прерывания INT0

  return (responce); // Возврат ответа
}