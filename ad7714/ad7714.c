//===============================================================
// ---=== AD7714 Routines for AVR family ===---
// AVR - ATmega2561-16 on Oscillator 14.318 MHz
// Процедуры обмена по SPI порту для 24-битного сигма-дельта АЦП AD7714AN-3
// (кварцевый резонатор 2,4576 MHz)
// *** Version 0.01 *** 16 Aug 2011 04:10 by (R)soft
// Параметры подключения микросхемы АЦП:
// POL=1 (полярность тактирования - данные защелкиваются по нарастающему фронту);
// /STANDBY=1 (Режим малого энергопотребления - выключен);
// /RESET=1 (Сброс АЦП - не используется; используется программный сброс);
// /CS=PB6 (Выбор кристалла - PORT B bit 6);
// /SYNC=1 (синхронизация параллельно включенных АЦП - не используется);
// /DRDY=PB4 (выход готовности данных преобразования - PORT B bit 4)
// BUFFER=1 (Буферизирование включено);
// Для обмена с АЦП используется аппаратный SPI, к шине SPI подключены
// выводы АЦП соответственно:
// DIN=PB2 MOSI (Линия передачи данных от MCU к АЦП);
// DOUT=PB3 MISO (Линия передачи данных от АЦП к MCU);
// SCLK=PB1 SCK (Линия тактирования данных по SPI).

//============================================================
// Процедура чтения байта с SPI
// 

unsigned char Read_SPI_7714 (void)
{
//  AD7714_PORT &= ~(1<<CS_7714); // CS=0

  SPDR = 0xFF;
  while (!(SPSR & (1<<SPIF)));

//  AD7714_PORT |= (1<<CS_7714);  // CS=1

  return SPDR;
}

//============================================================
// Процедура записи байта на SPI
// 

void Write_SPI_7714 (unsigned char byte)
{
//  AD7714_PORT &= ~(1<<CS_7714); // CS=0

  SPDR = byte;
  while (!(SPSR & (1<<SPIF)));

//  AD7714_PORT |= (1<<CS_7714); // CS=1
}

//=================================================
// Процедура инициализации интерфейса 7714

void Init_7714 (void)
{
  // Направление линий SPI и шины АЦП.
  // Неиспользуемые линии в состояние выхода с подтяжкой к лог. 1.
  // PB6 CS_7714 - на вывод, подтяжка на 1;
  // PB4 DRDY_7714 - на ввод, подтяжка на 1;
  // PB3 MISO - на ввод, подтяжка на 1;
  // PB2 MOSI - на вывод, подтяжка на 1;
  // PB1 SCK - на вывод, подтяжка на 1;
  // PB0 SS - обязательно установить в 1 на вывод, иначе SPI не будет работать.
  // 0xE7 1110 0111
  AD7714_DIR =  (1<<PB7)|(1<<CS_7714)|(1<<PB5)|(0<<DRDY_7714)|(0<<DD_MISO)|(1<<DD_MOSI)|(1<<DD_SCK)|(1<<PB0);

  // 0xFF 1111 1111
  AD7714_PORT = (1<<PB7)|(1<<CS_7714)|(1<<PB5)|(1<<DRDY_7714)|(1<<DD_MISO)|(1<<DD_MOSI)|(1<<DD_SCK)|(1<<PB0);

  // ========================= SPI SETUP
  // (0x5B by Default 0101 1011)
  // SPIE=0 SPE=1 DORD=0 MSTR=1  CPOL=1 CPHA=0 SPR1=1 SPR0=1
  // Bit7 SPIE=0 Interrupt Disable
  // Bit6 SPE=1 SPI Enable
  // Bit5 DORD=0 Data Order (MSB First)
  // Bit4 MSTR=1 SPI Mode (Master)
  // Bit3 CPOL=0 Clock Polarity=1 _/
  // Bit2 CPHA=0 Clock Phase
  // Bit1..0 SPR1=SPR0=1 Clock Rate 1/128 (период такта = 16 us)
  //         SPR1=SPR0=0 Clock Rate 1/4   (период такта = 500 нс) для ускорения
  
  // 0x5F 0101 0011
  SPCR = (0<<SPIE)|(1<<SPE)|(0<<DORD)|(1<<MSTR)|(0<<CPOL)|(0<<CPHA)|(1<<SPR1)|(1<<SPR0);
  
}

//==========================================================
// Процедура программного сброса 7714
// Чтобы сделать программный сброс АЦП, нужно выдать на шину
// подряд 64 бита лог единицы, т.е. 8 байт 0xFF подряд.

void Reset_7714 (void)
{
//  AD7714_PORT &= ~(1<<CS_7714); // CS=0

  unsigned char i;
  for (i=0;i<8;i++)
  {
    SPDR = 0xFF;
    while (!SPSR_SPIF);
  }

//  AD7714_PORT |= (1<<CS_7714); // CS=1
}

//=======================================================
// Процедура аппаратного опроса готовности 7714 по линии /DRDY.
// Устанавливает флаг ErrorFlag_7714=0 если готов или 0xFF если не готов (таймаут).
// Таймаут установлен 5 секунд.

/*
void Ready_7714 (void)
{
//  AD7714_PORT &= ~(1<<CS_7714); // CS=0

  unsigned int i;
  for (i=0;i<5000;i++)
  {
    if (!(AD7714_PIN&(1<<DRDY_7714))) // Если бит готовности DRDY=0
    {
      ErrorFlag_7714 = 0x00;
//      AD7714_PORT |= (1<<CS_7714); // CS=1
      return;
    }
    delay_ms(1);  // Немного подождем, если ещё не готов и продолжим опрос в цикле
  }

  ErrorFlag_7714 = 0xFF; // Если весь цикл тупили в опросе, то что-то очень долго никого нет... может умерли
//  AD7714_PORT |= (1<<CS_7714); // CS=1
}
*/

//=======================================================
// Процедура программного опроса готовности 7714.
// Устанавливает флаг ErrorFlag_7714=0 если готов или 0xFF если не готов (таймаут).
// Таймаут установлен 12 секунд.

void Ready_Soft_7714 (void)
{
//  AD7714_PORT &= ~(1<<CS_7714); // CS=0

  unsigned int i;
  for (i=0;i<12000;i++)
  {
    Write_SPI_7714 (0x08|(ADC7714_Channel&0x07));
//    unsigned char result = Read_SPI_7714();
    
    if ((Read_SPI_7714() & 0x80)==0) // Если бит готовности DRDY=0 (Bit7)
    {
      ErrorFlag_7714 = 0x00;
//      AD7714_PORT |= (1<<CS_7714); // CS=1
      return;
    }
    delay_ms(1);  // Немного подождем, если ещё не готов и продолжим опрос в цикле
  }

  ErrorFlag_7714 = 0xFF; // Если весь цикл тупили в опросе, то что-то очень долго никого нет... может умерли
//  AD7714_PORT |= (1<<CS_7714); // CS=1
}

//===========================================================
// Процедура 8-битного чтения из регистра 7714
// Вход: номер регистра АЦП [0..4]
// Выход: данные регистра АЦП;
//        флаг Error=0 если не было ошибки таймаута и флаг Error=0xFF если был таймаут

unsigned char ReadReg_7714 (unsigned char reg)
{
  Ready_Soft_7714(); // Опрос готовности АЦП
  if (ErrorFlag_7714) // Если был таймаут при опросе готовности АЦП, то
    {
      return 0; // Выходим из процедуры
    }
  // command=0x08 (0B00001000) - Команда чтения регистра
  // Смешиваем команду с номером канала и с номером регистра (номер регистра в старшую тетраду)
  Write_SPI_7714 (((reg&0x07)<<4)|0x08|(ADC7714_Channel&0x07)); 
  return Read_SPI_7714 (); // Читаем и возвращаем прочитанный регистр АЦП
}

//===========================================================
// Процедура 8-битной записи в регистр 7714
// Вход: номер регистра АЦП [0..4];
//       байт данных для записи.
// Выход: флаг ErrorFlag_7714=0 если не было ошибки таймаута и флаг ErrorFlag_7714=0xFF если был таймаут

void WriteReg_7714 (unsigned char reg, unsigned char byte)
{  
  Ready_Soft_7714();
  if (ErrorFlag_7714==0)
    {
      // Смешиваем номер канала и номер регистра (номер регистра в старшую тетраду)
      Write_SPI_7714 (((reg&0x07)<<4)|(ADC7714_Channel&0x07));
      Write_SPI_7714 (byte);
    }
}

//============================================================
// Процедура чтения 24-битного результата 7714
// Вход: -
// Выход: флаг ErrorFlag_7714=0 если не было ошибки таймаута и флаг ErrorFlag_7714=0xFF если был таймаут
//        если флаг=0, то результат записывается в переменные ADC7714_A, ADC7714_B, ADC7714_C.

void Read_ADC_7714 (void)
{
  Ready_Soft_7714 (); // Опрос готовности АЦП
  if (ErrorFlag_7714==0) // Если готовность АЦП - ОК, то
    {
      Write_SPI_7714 (0x58|(ADC7714_Channel&0x07)); // Команда чтения 24-битного значения из АЦП 0B0101 1000
      ADC7714_C = Read_SPI_7714();
      ADC7714_B = Read_SPI_7714();
      ADC7714_A = Read_SPI_7714();
    }
}